# Project: code2md

## Table of Contents

- [README.md](#file-readme-md)
- [src/extension.ts](#file-extension-ts)

## File: README.md <a id="file-readme-md"></a>

```markdown
# Code to Markdown (Code2Markdown) Extension for Visual Studio Code

The Code2MD Extension lets you convert selected code files in VS Code into a single Markdown file. Each file's content is wrapped in a syntax-highlighted code block, making it ideal for documentation, sharing, or archiving code snippets. It's especially useful for preparing code in an AI-friendly format for prompts.

## Why use Code2MD?

### Benefits for AI Prompts
- **Efficient Token Usage**: Markdown's lightweight syntax minimizes token counts, reducing costs with AI services.
- **Easy for AI to Understand**: Plain-text format with language identifiers (e.g., ```python) helps AI parse code accurately.
- **Organized and Readable**: Structure your codebase with headers and sections for clarity.
- **Faster Processing**: Markdown requires no preprocessing, speeding up AI response times.

### How Code2MD Saves Time and Money
- **One-Click Markdown Creation**: Automatically formats code into Markdown with proper code blocks.
- **Token Optimization**: Clean output reduces token usage, lowering costs.
- **Reduced Processing Time**: Structured Markdown helps AI understand your code faster.
- **Cost Savings**: Lower token counts and quicker interactions save money for programmers using AI services.

## Features
- Generate Markdown files from multiple files via the Command Palette or Explorer context menu.
- **Table of Contents**: Automatically generates a TOC with links to each included file.
- Unique file naming with timestamps and versioning to prevent overwrites.
- Syntax highlighting based on file extensions (e.g., `.ts` → `typescript`, `.py` → `python`, `.rs` → `rust`).
- Display of relative file paths for better context.
- Detailed logging for troubleshooting.

## Installation from VS Code

You can install the Code2MD Extension directly from the VS Code Marketplace within VS Code:

1. Open VS Code.
2. Click the Extensions icon in the Activity Bar or press `Ctrl+Shift+X` (Windows/Linux) or `Cmd+Shift+X` (macOS).
3. Search for `code2md`.
4. Look for "Code2MD Extension" by WIZWAM.
5. Click **Install**.

Alternatively, you can install it via the VS Code Quick Open command:
1. Open Quick Open with `Ctrl+P` (Windows/Linux) or `Cmd+P` (macOS).
2. Paste the following command and press Enter:
   ```
   ext install WIZWAM.Code2MD-Wizwam
   ```

## Installation from GitHub Repository

To install and test the extension directly from the GitHub repository, follow these steps:

1. **Clone the Repository**:
   - Clone the repository to your local machine:
     ```bash
     git clone https://github.com/lukejmorrison/code2md.git
     ```
   - Alternatively, download the repository as a ZIP file and extract it to a folder named `code2md`.

2. **Install Dependencies**:
   - Open a terminal in the `code2md` directory.
   - Run the following command to install the required dependencies:
     ```bash
     npm install
     ```

3. **Compile the Extension**:
   - Compile the TypeScript code into JavaScript:
     ```bash
     npm run compile
     ```
   - Alternatively, use `npm run watch` to automatically recompile on changes.

4. **Test the Extension in VS Code**:
   - Open the `code2md` folder in VS Code.
   - Press `F5` to launch a new VS Code window with the extension loaded.
   - Use the Command Palette or context menu to test Markdown generation.

## Usage

### Using the Command Palette
1. Open the Command Palette (`Ctrl+Shift+P` on Windows/Linux, `Cmd+Shift+P` on macOS).
2. Type `Generate Markdown from Files` and select it.
3. Choose one or more files in the file picker.
4. A Markdown file (e.g., `2023-10-25_0230PM_MyProject_v01.md`) will be created in your workspace root or the directory of the first selected file.

### Using Folder Selection (Recommended for Multiple Files)
1. Open the Command Palette (`Ctrl+Shift+P` on Windows/Linux, `Cmd+Shift+P` on macOS).
2. Type `Generate Markdown from Folder` and select it.
3. Choose a folder containing the files you want to include.  
   **Note**: Select the folder itself, not individual files within it.
4. Enter the file extensions to include (e.g., `rs,toml,html`).
5. The extension will recursively find all matching files and generate a Markdown file.

### Using the Context Menu
1. In the Explorer, select one or more files using `Ctrl+Click` (Windows/Linux) or `Cmd+Click` (macOS) for multiple selections.
2. Right-click and choose `Generate Markdown from Selected Files`.
3. A Markdown file with a Table of Contents and all selected files will be generated in your workspace root.  
   **Note**: If multiple file selection doesn’t work, use the "Generate Markdown from Folder" command instead.

### Output Format
The generated Markdown includes:
- A project title based on the workspace name.
- A Table of Contents with links to each file section.
- File sections with relative paths and syntax-highlighted code blocks.

## Troubleshooting
- **Log Files**: Check detailed logs in your workspace root (e.g., `code2md_YYYY-MM-DD_HHMMAM/PM.log`) for operation details.
- **Output Panel**: Open the Output panel in VS Code (`Ctrl+Shift+U`), select "Extension Host," and look for `[code2md]` messages.
- **Common Issues**:
  - **No files selected**: Ensure you select files or a folder as required by the command.
  - **Multiple file selection issues**: Use the "Generate Markdown from Folder" command if `Ctrl+Click` fails.
  - **Permission errors**: Verify VS Code has write access to the output directory.

## Development
- **Build**: Run `npm run compile` or `npm run watch`.
- **Folder Structure**:
  ```
  code2md/
  ├── src/                 # Source code
  │   └── extension.ts     # Main extension code
  ├── out/                 # Compiled JavaScript (generated)
  │   ├── extension.js     # Compiled extension
  │   └── extension.js.map # Source map
  ├── examples/            # Example files for testing
  ├── images/              # Extension icon
  │   └── code2md-icon.png
  ├── node_modules/        # Dependencies (generated)
  ├── .vscode/             # VS Code settings
  ├── package.json         # Project configuration and dependencies
  ├── package-lock.json    # Dependency lock file
  ├── tsconfig.json        # TypeScript compiler configuration
  └── README.md            # Project documentation
  ```

## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
```

## File: src/extension.ts <a id="file-extension-ts"></a>

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

// Create a log file in the extension's directory
let logFilePath: string;

// Helper function to write to log file
function logToFile(message: string): void {
    if (!logFilePath) {
        // Initialize log file path if not already set
        const timestamp = getFormattedTimestamp();
        const logFileName = `code2md_${timestamp}.log`;
        
        // Try to use workspace folder first, fall back to temp directory
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            logFilePath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, logFileName);
        } else {
            // Fallback to extension directory
            logFilePath = path.join(__dirname, '..', logFileName);
        }
        
        // Create or clear the log file
        fs.writeFileSync(logFilePath, `Code2MD Extension Log - ${new Date().toISOString()}\n\n`);
        
        // Log sanitized path
        const sanitizedPath = vscode.workspace.workspaceFolders?.[0] ? 
            path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, logFilePath)
                .split(path.sep).join('/') : 
            path.basename(logFilePath);
        console.log(`[code2md] Log file created at: ${sanitizedPath}`);
    }
    
    // Append to log file
    try {
        const logMessage = `${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(logFilePath, logMessage);
        console.log(message); // Also log to console
    } catch (error) {
        console.error(`[code2md] Error writing to log file: ${error}`);
    }
}

// Generates a timestamp for unique file naming
function getFormattedTimestamp(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    
    // Convert to 12-hour format with AM/PM
    let hours = now.getHours();
    const ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    const hoursStr = hours.toString().padStart(2, '0');
    
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    
    return `${year}-${month}-${day}_${hoursStr}${minutes}${ampm}`;
}

// Determines the output file path, ensuring uniqueness with versioning
function getOutputFilePath(files: vscode.Uri[]): string {
    const timestamp = getFormattedTimestamp();
    let rootFolderName: string;
    let outputDir: string;

    // Use workspace folder if available; otherwise, fall back to the directory of the first file
    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
        rootFolderName = vscode.workspace.workspaceFolders[0].name;
        outputDir = vscode.workspace.workspaceFolders[0].uri.fsPath;
    } else {
        rootFolderName = "CodeExport";
        outputDir = path.dirname(files[0].fsPath);
    }

    // Check existing files in the directory to determine the next version number
    // Get the date part of the timestamp (YYYY-MM-DD)
    const datePart = timestamp.split('_')[0];
    
    // Find all files that match the current date
    let version = 1;
    try {
        const files = fs.readdirSync(outputDir);
        // Filter files that match the current date and pattern
        const todaysFiles = files.filter(file => 
            file.startsWith(datePart) && 
            file.includes(rootFolderName) && 
            file.endsWith('.md') &&
            file.match(/_v\d+\.md$/)
        );
        
        // Extract the highest version number from today's files
        if (todaysFiles.length > 0) {
            // Extract version numbers from filenames
            const versions = todaysFiles.map(file => {
                const match = file.match(/_v(\d+)\.md$/);
                return match ? parseInt(match[1], 10) : 0;
            });
            
            // Get the highest version number and increment it
            const highestVersion = Math.max(...versions);
            version = highestVersion + 1;
            logToFile(`[code2md] Found ${todaysFiles.length} existing files today, highest version: ${highestVersion}`);
        }
    } catch (error) {
        logToFile(`[code2md] Error reading directory for versioning: ${error}`);
        // Fallback to default version 1
    }
    
    const paddedVersion = version.toString().padStart(2, '0');
    const filename = `${timestamp}_${rootFolderName}_v${paddedVersion}.md`;
    const outputPath = path.join(outputDir, filename);
    
    logToFile(`[code2md] Output path set to: ${outputPath} (Version: ${version})`);
    return outputPath;
}

// Generates Markdown content from selected files with syntax-highlighted code blocks
async function generateMarkdown(files: vscode.Uri[]): Promise<string> {
    // Sanitize file paths for logging
    const sanitizedPaths = files.map(f => {
        return vscode.workspace.workspaceFolders?.[0] ? 
            path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, f.fsPath)
                .split(path.sep).join('/') : // Convert to forward slashes
            path.basename(f.fsPath);
    });
    
    logToFile(`[code2md] Generating Markdown for files: ${sanitizedPaths.join(', ')}`);

    const outputPath = getOutputFilePath(files);
    
    // Sanitize workspace name
    const workspaceName = (vscode.workspace.workspaceFolders?.[0]?.name || 
        path.basename(vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || 'NoWorkspace'))
        .replace(/[^\w\s-]/g, '') // Remove non-alphanumeric characters except spaces and hyphens
        .trim();

    let markdownContent = `# Project: ${workspaceName}\n\n`;
    
    // Add Table of Contents
    markdownContent += `## Table of Contents\n\n`;
    for (const file of files) {
        const fileName = path.basename(file.fsPath);
        const fileRelativePath = vscode.workspace.workspaceFolders?.[0] ? 
            path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, file.fsPath)
                .split(path.sep).join('/') : // Convert to forward slashes
            fileName;
        // Create a valid ID by replacing special characters
        const fileId = fileName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        markdownContent += `- [${fileRelativePath}](#file-${fileId})\n`;
    }
    markdownContent += `\n`;

    // Process each file
    let processedCount = 0;
    for (const file of files) {
        const sanitizedPath = vscode.workspace.workspaceFolders?.[0] ? 
            path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, file.fsPath)
                .split(path.sep).join('/') : 
            path.basename(file.fsPath);
            
        logToFile(`[code2md] Processing file: ${sanitizedPath}`);
        try {
            const content = fs.readFileSync(file.fsPath, 'utf8');
            const fileExtension = path.extname(file.fsPath).substr(1);
            const language = getLanguageFromExtension(fileExtension);
            const fileName = path.basename(file.fsPath);
            const fileRelativePath = vscode.workspace.workspaceFolders?.[0] ? 
                path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, file.fsPath)
                    .split(path.sep).join('/') : 
                fileName;
            // Create a valid ID by replacing special characters
            const fileId = fileName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();

            markdownContent += `## File: ${fileRelativePath} <a id="file-${fileId}"></a>\n\n`;
            markdownContent += language ? `\`\`\`${language}\n${content}\n\`\`\`\n\n` : `\`\`\`\n${content}\n\`\`\`\n\n`;
            processedCount++;
        } catch (error) {
            logToFile(`[code2md] Error processing file ${sanitizedPath}: ${error}`);
            // Continue with other files
        }
    }

    try {
        fs.writeFileSync(outputPath, markdownContent);
        const sanitizedOutputPath = vscode.workspace.workspaceFolders?.[0] ? 
            path.relative(vscode.workspace.workspaceFolders[0].uri.fsPath, outputPath)
                .split(path.sep).join('/') : 
            path.basename(outputPath);
        logToFile(`[code2md] Markdown file written to: ${sanitizedOutputPath} with ${processedCount} of ${files.length} files`);
        return outputPath;
    } catch (error) {
        logToFile(`[code2md] Error writing Markdown file: ${error}`);
        throw new Error(`Failed to write Markdown file: ${error}`);
    }
}

// Maps file extensions to Markdown language identifiers for syntax highlighting
function getLanguageFromExtension(extension: string): string | undefined {
    const languageMap: { [key: string]: string } = {
        'ts': 'typescript',
        'js': 'javascript',
        'py': 'python',
        'cpp': 'cpp',
        'java': 'java',
        'cs': 'csharp',
        'rb': 'ruby',
        'swift': 'swift',
        'kt': 'kotlin',
        'go': 'go',
        'php': 'php',
        'html': 'html',
        'css': 'css',
        'json': 'json',
        'md': 'markdown',
        'rs': 'rust',
        'toml': 'toml'
    };
    return languageMap[extension.toLowerCase()];
}

// Activates the extension and registers commands
export function activate(context: vscode.ExtensionContext) {
    console.log('[code2md] Code to Markdown extension activated');

    // Command Palette command: Opens file picker and generates Markdown
    const commandPalette = vscode.commands.registerCommand('code2md.generateMarkdown', async () => {
        logToFile('[code2md] Command Palette: Generate Markdown triggered');
        const files = await vscode.window.showOpenDialog({
            canSelectFiles: true,
            canSelectMany: true,
            openLabel: 'Select Files for Markdown'
        });

        if (!files || files.length === 0) {
            logToFile('[code2md] No files selected in Command Palette');
            vscode.window.showErrorMessage('No files selected.');
            return;
        }

        logToFile(`[code2md] Selected ${files.length} files via Command Palette`);
        
        try {
            const outputPath = await generateMarkdown(files);
            const successMessage = `Markdown file generated with ${files.length} files at: ${outputPath}`;
            logToFile(`[code2md] ${successMessage}`);
            vscode.window.showInformationMessage(successMessage);
            
            // Show the generated file
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);
        } catch (error) {
            const errorMessage = `Error generating Markdown: ${error}`;
            logToFile(`[code2md] ${errorMessage}`);
            vscode.window.showErrorMessage(errorMessage);
        }
    });

    // New command: Generate Markdown from a folder
    const folderCommand = vscode.commands.registerCommand('code2md.generateMarkdownFromFolder', async () => {
        logToFile('[code2md] Folder Command: Generate Markdown from folder triggered');
        
        // Ask user to select a folder
        const folders = await vscode.window.showOpenDialog({
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false,
            openLabel: 'Select Folder'
        });

        if (!folders || folders.length === 0) {
            logToFile('[code2md] No folder selected');
            vscode.window.showErrorMessage('Please select a folder to generate Markdown from (not individual files).');
            return;
        }

        const folderPath = folders[0].fsPath;
        logToFile(`[code2md] Selected folder: ${folderPath}`);

        // Ask user for file extensions to include
        const extensionsInput = await vscode.window.showInputBox({
            prompt: 'Enter file extensions to include (comma separated, e.g., ts,js,py,rs,toml,html)',
            value: 'ts,js,py,rs,toml,html,css,json,md'
        });

        if (!extensionsInput) {
            logToFile('[code2md] No extensions provided');
            vscode.window.showErrorMessage('No file extensions provided.');
            return;
        }

        const extensions = extensionsInput.split(',').map(ext => ext.trim().toLowerCase());
        logToFile(`[code2md] File extensions to include: ${extensions.join(', ')}`);

        // Find all matching files in the folder
        const files: vscode.Uri[] = [];
        
        // Helper function to recursively find files
        const findFiles = (dirPath: string) => {
            try {
                const entries = fs.readdirSync(dirPath, { withFileTypes: true });
                
                for (const entry of entries) {
                    const fullPath = path.join(dirPath, entry.name);
                    
                    if (entry.isDirectory()) {
                        // Skip node_modules and hidden folders
                        if (entry.name !== 'node_modules' && !entry.name.startsWith('.')) {
                            findFiles(fullPath);
                        }
                    } else if (entry.isFile()) {
                        const ext = path.extname(entry.name).substring(1).toLowerCase();
                        if (extensions.includes(ext)) {
                            files.push(vscode.Uri.file(fullPath));
                            logToFile(`[code2md] Found matching file: ${fullPath}`);
                        }
                    }
                }
            } catch (error) {
                logToFile(`[code2md] Error reading directory ${dirPath}: ${error}`);
                throw error;
            }
        };
        
        try {
            findFiles(folderPath);
            logToFile(`[code2md] Found ${files.length} matching files`);
            
            if (files.length === 0) {
                const message = `No files with extensions ${extensions.join(', ')} found in the selected folder.`;
                logToFile(`[code2md] ${message}`);
                vscode.window.showErrorMessage(message);
                return;
            }
            
            const outputPath = await generateMarkdown(files);
            const successMessage = `Markdown file generated with ${files.length} files at: ${outputPath}`;
            logToFile(`[code2md] ${successMessage}`);
            vscode.window.showInformationMessage(successMessage);
            
            // Show the generated file
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);
        } catch (error) {
            const errorMessage = `Error finding files: ${error}`;
            logToFile(`[code2md] ${errorMessage}`);
            vscode.window.showErrorMessage(errorMessage);
        }
    });

    // Context Menu command: Generates Markdown from Explorer-selected files
    const contextMenu = vscode.commands.registerCommand('code2md.generateMarkdownContext', async (...args: any[]) => {
        logToFile('[code2md] Context Menu: Generate Markdown triggered');
        logToFile(`[code2md] Raw args length: ${args.length}`);
        logToFile(`[code2md] Raw args: ${JSON.stringify(args.map(arg => typeof arg))}`);
        
        // Detailed logging of arguments
        for (let i = 0; i < args.length; i++) {
            logToFile(`[code2md] Arg ${i} type: ${typeof args[i]}`);
            logToFile(`[code2md] Arg ${i} is array: ${Array.isArray(args[i])}`);
            if (typeof args[i] === 'object') {
                const keys = Object.keys(args[i]).join(', ');
                logToFile(`[code2md] Arg ${i} keys: ${keys}`);
                if (args[i].fsPath) {
                    logToFile(`[code2md] Arg ${i} fsPath: ${args[i].fsPath}`);
                }
                if (args[i].length) {
                    logToFile(`[code2md] Arg ${i} length: ${args[i].length}`);
                    if (args[i][0] && args[i][0].fsPath) {
                        logToFile(`[code2md] Arg ${i}[0] fsPath: ${args[i][0].fsPath}`);
                    }
                }
            }
        }
        
        // From the example, we can see that multiple files might be passed as the second argument
        // if it's an array of vscode.Uri objects
        let selectedFiles: vscode.Uri[] = [];
        
        try {
            // Based on the example file, check if args follow the pattern [any, Uri[]]
            if (args.length === 2 && Array.isArray(args[1]) && 
                args[1].every((item: any) => item instanceof Object && item.fsPath)) {
                // Multiple files selected (same pattern as the example)
                selectedFiles = args[1];
                logToFile('[code2md] Files from second argument array');
            } 
            // If we have a single Uri as the first argument
            else if (args.length === 1 && args[0] instanceof Object && args[0].fsPath) {
                selectedFiles = [args[0]];
                logToFile('[code2md] Single file from first argument');
            }
            // Handle the case where an array is the first argument
            else if (args.length === 1 && Array.isArray(args[0]) && 
                    args[0].every((item: any) => item instanceof Object && item.fsPath)) {
                selectedFiles = args[0];
                logToFile('[code2md] Files from first argument array');
            }
            // Handle multiple URI arguments directly
            else if (args.length > 0 && args.every((arg: any) => arg instanceof Object && arg.fsPath)) {
                selectedFiles = args;
                logToFile('[code2md] Files from multiple arguments');
            }
            // Let's try one more approach, used by some VS Code extensions
            else if (args.length > 0 && args[0] && typeof args[0] === 'object' && args[0].scheme === 'file') {
                // Try to extract directly as Uri
                selectedFiles = [args[0] as vscode.Uri];
                logToFile('[code2md] Single file from first argument as direct Uri');
            }
            
            // If active text editor is available and we still don't have files, use that
            if (selectedFiles.length === 0 && vscode.window.activeTextEditor) {
                selectedFiles = [vscode.window.activeTextEditor.document.uri];
                logToFile('[code2md] Used active text editor document');
            }
            
            // Additional fallback: try to find an array of uris in the arguments
            if (selectedFiles.length === 0) {
                for (const arg of args) {
                    if (arg && Array.isArray(arg)) {
                        const uris = arg.filter((item: any) => item && typeof item === 'object' && item.fsPath);
                        if (uris.length > 0) {
                            selectedFiles = uris;
                            logToFile('[code2md] Found uris array in an argument');
                            break;
                        }
                    }
                }
            }
        } catch (error) {
            logToFile(`[code2md] Error during file selection: ${error}`);
        }
        
        // Log what we found
        logToFile(`[code2md] Selected files count: ${selectedFiles.length}`);
        if (selectedFiles.length > 0) {
            logToFile(`[code2md] Selected files: ${selectedFiles.map(f => f.fsPath).join(', ')}`);
        }
        
        if (!selectedFiles || selectedFiles.length === 0) {
            logToFile('[code2md] No files selected in Context Menu');
            vscode.window.showErrorMessage('No files selected. Please select one or more files before running this command, or use "Generate Markdown from Folder" instead.');
            return;
        }

        try {
            const outputPath = await generateMarkdown(selectedFiles);
            const successMessage = `Markdown file generated with ${selectedFiles.length} files at: ${outputPath}`;
            logToFile(`[code2md] ${successMessage}`);
            vscode.window.showInformationMessage(successMessage);
            
            // Show the generated file
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);
        } catch (error) {
            const errorMessage = `Error generating Markdown: ${error}`;
            logToFile(`[code2md] ${errorMessage}`);
            vscode.window.showErrorMessage(errorMessage);
        }
    });

    context.subscriptions.push(commandPalette, folderCommand, contextMenu);
}

// Deactivates the extension (currently a no-op)
export function deactivate() {
    console.log('[code2md] Extension deactivated');
}
```

